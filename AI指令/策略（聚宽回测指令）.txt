工作场景：
你是一名非常优秀的计算机工程师，注重代码的简洁性和可维护性，熟练使用聚宽API进行量化交易及回测
同时你的代码当中很少有bug存在。此外，你在任务开始时，习惯性添加一句print（'任务已经开始'），以方便测试

注意事项：
只使用聚宽API文件当中提供的函数，不要使用其他任何方法，初始资金设置为一百万

工作任务:
1.在聚宽平台上进行回测（代码运行在聚宽回测平台上即可）沪深三百指数的股票池中的股票；
2.每天选取当天开盘与昨日开盘比值最高的百分之十的股票，从中选出开盘价最低的五只；
4.以上指标都满足要求后，才买入股票，否则当天不买入股票；
5.股票以当日开盘买入，持有六天后卖出

聚宽API：
https://www.joinquant.com/help/api/help#name:api


参考资料：
# 初始化回测函数，在此处添加打印语句
def initialize(context):
    print('任务已经开始')
    # 设定沪深300作为基准
    set_benchmark('000300.XSHG')
    # 开启动态复权模式(真实价格)
    set_option('use_real_price', True)
    # 开启避免未来函数模式
    set_option("avoid_future_data", True)
    # 输出内容到日志 log.info()
    log.info('初始函数开始运行且全局只运行一次')
    # 过滤掉order系列API产生的比error级别低的log
    log.set_level('order', 'error')
    # # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱
    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0001, close_commission=0.0001, min_commission=5), type='stock')
    

def handle_data(context, data):
    today = context.current_dt.date()
    yestoday=context.previous_date
    # 获取股票池中的股票
    # stocks = get_index_stocks('000300.XSHG', date=today)
    # 获取当日可以交易的全部股票
    stocks = list(get_all_securities(['stock'], today).index)

    # 获取今天的数据
    df = get_price(stocks, start_date=today, end_date=today, frequency='daily', fields=['open']).to_frame()
    # 获取前一天的数据
    df_pre = get_price(stocks, start_date=yestoday, end_date=yestoday, frequency='daily', fields=['open']).to_frame()
    # 将两个 DataFrame 合并为一个 DataFrame，只保留两个 DataFrame 都包含的行
    df_merge = pd.merge(df, df_pre, on='minor', suffixes=('today', 'yesterday')).dropna()
    df_ratio = (df_merge['opentoday'] / df_merge['openyesterday']).to_frame()
    df_ratio = df_ratio.dropna()
    # 筛选出开盘与昨日开盘比值最高的前10%
    top_ratio = df_ratio.stack().nlargest(int(len(df_ratio) * 0.1)).reset_index()
    top_ratio.columns = ['code', 'level_1', 'ratio']
    # 从中获取获取开盘价最低的前5只股票代码
    lowest_open = top_ratio.nsmallest(5, 'ratio')['code'].tolist()
    # 如果股票满足以下条件则进入交易池
    buy_list = []
    for stock in lowest_open:
        # 获取股票的当前价格和前一天的价格
        price = attribute_history(stock, 2, '1d', ['open'], df=False)['open']
        # 判断股票是否在停牌状态，昨天或今天的开盘价为0
        if price[0] == 0 or price[1] == 0:
            continue
        # 判断是否涨跌停
        close_price = attribute_history(stock, 2, '1d', ['close'], df=False)['close']
        if close_price[0] > price[1] :
            continue
        if close_price[0]*1.08 <= price[1] :
            continue
        # 如果符合条件，则将股票加入买入列表中
        buy_list.append(stock)
    print(buy_list)
    
    # 卖出持仓超过6个交易日且当天开盘涨幅未超过百分之8的股票
    for stock in context.portfolio.positions:
        held_days = (today - context.portfolio.positions[stock].init_time.date()).days
        price = attribute_history(stock, 2, '1d', ['open', 'close'], df=False)
        increase = (price['open'][0] - price['close'][1]) / price['close'][1]
        if held_days >= 6 and increase <= 0.08:
            order_target_value(stock, 0)
            log.info("Selling %s", stock)
            
    # 如果有符合条件的股票，则平均买入
    if len(buy_list) > 0:
        target_value = context.portfolio.portfolio_value * 0.98
        value_per_stock = target_value / len(buy_list)/6
        for stock in buy_list:
            order_target_value(stock, value_per_stock)
            log.info("Buying %s", stock)
            
    # for stock in context.portfolio.positions:
    #     print（stock）
        # held_days = (today - context.portfolio.positions[stock].init_time.date()).days
        # if held_days >= 6:
        #     # 获取当前股票涨幅
        #     current_return = (context.portfolio.positions[stock].last_price - context.portfolio.positions[stock].avg_cost) 
        #     / context.portfolio.positions[stock].avg_cost
            
            
        #     # 如果涨幅超过限制，则继续持有，否则卖出
        #     if current_return >= 0.05:
        #         log.info("%s is in limit up, continue to hold", stock)
        #     else:
        #         order_target_value(stock, 0)
        #         log.info("Selling %s", stock)
                
