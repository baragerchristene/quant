工作场景：
你是一名非常优秀的计算机工程师，注重代码的简洁性和可维护性，并且习惯采用向量化计算的手段提高代码的运行效率，同时你的代码当中很少有bug存在

一、注意事项：
1.尽量使用向量化计算，避免使用if语句和for循环，避免频繁使用解释器导致效率降低
2.所有的数据在数据库当中已经包含，不需要再次计算
3.直接给我完整代码
4.可以使用参考资料，但是不一定准确，请你批判的使用
二、规则说明
1.当当天所有股票['EMA121开盘比值']的乘积大于1.1的时候执行牛市策略；
当当天所有股票['EMA121开盘比值']的乘积小于0.9的时候执行熊市策略；其他时间执行震荡策略，要求每日单独执行单独的策略，互相之间不要干扰
2.注意事项:最开始遍历的日期也不应该是固定值，而是把读取到的数据中的日期从早到晚遍历，减少计算量。
3.按照日期对所有交易细节输出为对应的f'{name}交易细节.csv'
4.按照日期对平均收益率和净资产走势输出为对应的f'{name}收益率和净资产收益率.csv'
三、补充说明
参考资料：
一、牛市策略
import pandas as pd

name = 'STOCK_20140101_20170101'
# name = 'COIN'
# name = 'STOCK'
df = pd.read_csv(f'{name}指标.csv')

# 去掉n日后总涨跌幅大于百分之三百的噪音数据
for n in range(1, 9):
    df = df[df[f'{n}日后总涨跌幅（未来函数）'] <= 300*(1+n*0.2)]

df = df[df['EMA121开盘比值'] >= 2].copy()

# 每日选STOCK
n_stock = 100
df = df.groupby('日期').apply(lambda x: x.nsmallest(
    n_stock, 'EMA9开盘动能4')).reset_index(drop=True)
n_stock = 5
df = df.groupby('日期').apply(lambda x: x.nsmallest(
    n_stock, '开盘')).reset_index(drop=True)
df = df[
    (df['开盘收盘幅'] <= 8)
    &
    (df['开盘收盘幅'] >= 0)
]

# 将交易标的细节输出到一个csv文件
trading_detail_filename = f'{name}交易标的细节.csv'
df.to_csv(trading_detail_filename, index=False)

# 假设开始时有10000元资金,实操时每个月还得归集一下资金，以免收益不平均
cash_balance = 10000
# 用于记录每日的资金余额
daily_cash_balance = {}
n = 1
# 设置持仓周期
m = 0
# 设置手续费

df_strategy = pd.DataFrame(columns=['日期', '执行策略'])
df_daily_return = pd.DataFrame(columns=['日期', '收益率'])

cash_balance_list = []
# 记录每个交易日是否执行了策略，并输出到csv文件中
for date, group in df.groupby('日期'):
    # 如果当日没有入选标的，则单日收益率为0
    if group.empty:
        daily_return = 0
    else:
        daily_return = (group[f'{n}日后总涨跌幅（未来函数）'] +
                        100).mean()*(1-m)/100-1  # 计算平均收益率
    df_daily_return = pd.concat(
        [df_daily_return, pd.DataFrame({'日期': [date], '收益率': [daily_return]})])
    # 更新资金余额并记录每日资金余额
    cash_balance *= (1 + daily_return)
    daily_cash_balance[date] = cash_balance
    cash_balance_list.append(cash_balance)  # 添加每日资金余额到列表中
df_cash_balance = pd.DataFrame({'日期': list(daily_cash_balance.keys()), '资金余额': list(daily_cash_balance.values())})
df_strategy_and_return = pd.merge(df_daily_return, df_cash_balance, on='日期')
# 输出每日执行策略和净资产收益率到csv文件
df_strategy_and_return.to_csv(f'{name}每日策略和资产状况.csv', index=False)
二、熊市策略
import pandas as pd

name = 'STOCK_20140101_20170101'
# name = 'COIN'
# name = 'STOCK'
df = pd.read_csv(f'{name}指标.csv')

# 去掉n日后总涨跌幅大于百分之三百的噪音数据
for n in range(1, 9):
    df = df[df[f'{n}日后总涨跌幅（未来函数）'] <= 300*(1+n*0.2)]

df = df[df['EMA121开盘比值'] <= 0.8].copy()

n_stock = 100
df = df.groupby('日期').apply(lambda x: x.nsmallest(
    n_stock, '开盘')).reset_index(drop=True)
n_stock = 5
df = df.groupby('日期').apply(lambda x: x.nsmallest(
    n_stock, 'EMA121开盘比值')).reset_index(drop=True)
df = df[
    (df['开盘收盘幅'] <= 8)
    &
    (df['开盘收盘幅'] >= 0)
]

# 将交易标的细节输出到一个csv文件
trading_detail_filename = f'{name}交易标的细节.csv'
df.to_csv(trading_detail_filename, index=False)

# 假设开始时有10000元资金,实操时每个月还得归集一下资金，以免收益不平均
cash_balance = 10000
# 用于记录每日的资金余额
daily_cash_balance = {}
n = 1
# 设置持仓周期
m = 0
# 设置手续费

df_strategy = pd.DataFrame(columns=['日期', '执行策略'])
df_daily_return = pd.DataFrame(columns=['日期', '收益率'])

cash_balance_list = []
# 记录每个交易日是否执行了策略，并输出到csv文件中
for date, group in df.groupby('日期'):
    # 如果当日没有入选标的，则单日收益率为0
    if group.empty:
        daily_return = 0
    else:
        daily_return = (group[f'{n}日后总涨跌幅（未来函数）'] +
                        100).mean()*(1-m)/100-1  # 计算平均收益率
    df_daily_return = pd.concat(
        [df_daily_return, pd.DataFrame({'日期': [date], '收益率': [daily_return]})])
    # 更新资金余额并记录每日资金余额
    cash_balance *= (1 + daily_return)
    daily_cash_balance[date] = cash_balance
    cash_balance_list.append(cash_balance)  # 添加每日资金余额到列表中
df_cash_balance = pd.DataFrame(
    {'日期': list(daily_cash_balance.keys()), '资金余额': list(daily_cash_balance.values())})
df_strategy_and_return = pd.merge(df_daily_return, df_cash_balance, on='日期')
# 输出每日执行策略和净资产收益率到csv文件
df_strategy_and_return.to_csv(f'{name}每日策略和资产状况.csv', index=False)
三、震荡策略
import pandas as pd

# name = 'STOCK_20140101_20170101'
# name = 'COIN'
name = 'STOCK'
df = pd.read_csv(f'{name}指标.csv')

# 去掉n日后总涨跌幅大于百分之三百的噪音数据
for n in range(1, 9):
    df = df[df[f'{n}日后总涨跌幅（未来函数）'] <= 300*(1+n*0.2)]

n_stock = 100
df = df.groupby('日期').apply(lambda x: x.nlargest(
    n_stock, '开盘开盘幅')).reset_index(drop=True)
n_stock = 5
df = df.groupby('日期').apply(lambda x: x.nsmallest(
    n_stock, '开盘')).reset_index(drop=True)
if 'stock' in name.lower():
    df = df[
        (df['开盘收盘幅'] <= 8)
        &
        (df['开盘收盘幅'] >= 0)
    ]
    print('测试标的为股票类型，默认高开百分之八无法买入')

# 将交易标的细节输出到一个csv文件
trading_detail_filename = f'{name}交易标的细节.csv'
df.to_csv(trading_detail_filename, index=False)

# 假设开始时有10000元资金,实操时每个月还得归集一下资金，以免收益不平均
cash_balance = 10000
# 用于记录每日的资金余额
daily_cash_balance = {}
n = 1
# 设置持仓周期
m = 0
# 设置手续费

df_strategy = pd.DataFrame(columns=['日期', '执行策略'])
df_daily_return = pd.DataFrame(columns=['日期', '收益率'])

cash_balance_list = []
# 记录每个交易日是否执行了策略，并输出到csv文件中
for date, group in df.groupby('日期'):
    # 如果当日没有入选标的，则单日收益率为0
    if group.empty:
        daily_return = 0
    else:
        daily_return = (group[f'{n}日后总涨跌幅（未来函数）'] +
                        100).mean()*(1-m)/100-1  # 计算平均收益率
    df_daily_return = pd.concat(
        [df_daily_return, pd.DataFrame({'日期': [date], '收益率': [daily_return]})])
    # 更新资金余额并记录每日资金余额
    cash_balance *= (1 + daily_return)
    daily_cash_balance[date] = cash_balance
    cash_balance_list.append(cash_balance)  # 添加每日资金余额到列表中
df_cash_balance = pd.DataFrame(
    {'日期': list(daily_cash_balance.keys()), '资金余额': list(daily_cash_balance.values())})
df_strategy_and_return = pd.merge(df_daily_return, df_cash_balance, on='日期')
# 输出每日执行策略和净资产收益率到csv文件
df_strategy_and_return.to_csv(f'{name}每日策略和资产状况.csv', index=False)
