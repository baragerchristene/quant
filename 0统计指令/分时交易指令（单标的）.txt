工作场景：
你是一名非常优秀的计算机工程师，注重代码的简洁性和可维护性，并且习惯采用向量化计算的手段提高代码的运行效率，同时你的代码当中很少有bug存在

工作任务：
一、注意事项：
1.尽量使用向量化计算，避免使用if语句和for循环，避免频繁使用解释器导致效率降低
2.所有的数据在数据库当中已经包含，不需要再次计算
3.直接给我完整的python代码
4.可以使用参考资料，但是不一定准确，请你批判的使用
二、规则说明
3.选取‘EMA9收盘动能3’大于1.03且‘EMA121收盘比值’小于0.5的时刻认为是我们的交易机会
4.按照日期对所有交易细节输出为对应的交易细节.csv
6.按照日期对平均收益率输出为对应的收益率和净资产收益率.csv

三、参考代码
import pandas as pd

name = 'COIN'
df = pd.read_csv(f'{name}指标.csv')
df = df.dropna()
# 去掉n日后总涨跌幅大于百分之三百的噪音数据
for n in range(1, 10):
    df = df[df[f'{n}日后总涨跌幅（未来函数）'] <= 300*(1+n*0.2)]
# 四均线过滤COIN0.8
df = df[df['EMA121收盘比值'] <= 0.5].copy()
df = df[df['EMA121开盘比值'] <= 0.5].copy()
df = df[df['EMA121最高比值'] <= 0.5].copy()
df = df[df['EMA121最低比值'] <= 0.5].copy()
# # 四均线过滤STOCK0.8
# df = df[df['EMA121收盘比值'] <= 0.8].copy()
# df = df[df['EMA121开盘比值'] <= 0.8].copy()
# df = df[df['EMA121最高比值'] <= 0.8].copy()
# df = df[df['EMA121最低比值'] <= 0.8].copy()

# 动能过滤只要最佳的四只
n_stock = 4
df = df.groupby('日期').apply(
    lambda x: x.nlargest(n_stock, 'EMA9收盘动能3')).reset_index(drop=True)
# 过滤COIN(df['开盘'] <= 0.9)(df['开盘幅'] <= 9.9)(df['开盘幅'] >= -0.01)
df_stock_filtered = df[(df['开盘'] <= 0.9) &
                       (df['开盘幅'] <= 9.9) &
                       (df['开盘幅'] >= -0.01)]
# # 过滤COIN(df['开盘'] <= 31)(df['开盘幅'] <= 9.9)(df['开盘幅'] >= -2)(df['换手率'] <= 3.3)
# df_stock_filtered = df[(df['开盘'] <= 31) &
#                        (df['开盘幅'] <= 9.9) &
#                        (df['开盘幅'] >= -2) &
#                        (df['换手率'] <= 3.3)]

# 将交易标的细节输出到一个csv文件
trading_detail_filename = '交易标的细节.csv'
df_stock_filtered.to_csv(trading_detail_filename, index=False)

# 计算每日收益率=100*(100+FJ2-2)/100
df_daily_return = pd.DataFrame(columns=['日期', '收益率'])

# 假设开始时有10000元资金
cash_balance = 10000

# 用于记录每日的资金余额
daily_cash_balance = {}

for date, group in df_stock_filtered.groupby('日期'):
    # 如果当日没有入选标的，则单日收益率为0
    if group.empty:
        daily_return = 0
    else:
        # 计算单日收益率
        group['daily_return'] = (
            group['6日后总涨跌幅（未来函数）']/100 + 1-0.02).prod() - 1

        # 计算平均收益率
        daily_return = group['daily_return'].mean()

    # 更新资金余额并记录每日资金余额
    cash_balance *= (1 + daily_return)
    daily_cash_balance[date] = cash_balance

    # 记录每日净资产收益率
    df_daily_return = df_daily_return.append(
        {'日期': date, '收益率': daily_return}, ignore_index=True)

# 输出每日净资产收益率到csv文件
df_daily_return.to_csv('每日净资产收益率.csv', index=False)

# 将每日资金余额转换为DataFrame
df_cash_balance = pd.DataFrame(
    {'日期': list(daily_cash_balance.keys()), '资金余额': list(daily_cash_balance.values())})

# 将每日资金余额输出到csv文件
df_cash_balance.to_csv('每日资金余额.csv', index=False)
