工作场景：
你是一名非常优秀的计算机工程师，注重代码的简洁性和可维护性，并且习惯采用向量化计算的手段提高代码的运行效率，同时你的代码当中很少有bug存在

工作任务：
一、注意事项：
1.尽量使用向量化计算，避免使用if语句和for循环，避免频繁使用解释器导致效率降低
2.所有的数据在数据库当中已经包含，不需要再次计算
3.直接给我完整代码
4.可以使用参考资料，但是不一定准确，请你批判的使用
二、规则说明
1.以日期为索引进行分组
2.选取每一天内‘EMA9收盘动能3’最大的四十分之一股票进入备选池
3.继续选取每一天内‘EMA9收盘动能3’最大的四十分之一股票中‘EMA121收盘比值’最小的四十分之一股票进入统计范围，作为交易标的
4.每天对所有股票的交易标的细节输出为对应的交易细节.csv
6.每天对所有股票的平均收益率输出为对应的收益率.csv

这里里面需要在一开始把资金分成n份，每份资金在n+1日以后才能进行交易，每个月归集一下资金，把资金打匀，这样的话收益率和净资产走势都有变化，请给我这样一份代码

三、参考代码
import pandas as pd

name = 'COIN'
df = pd.read_csv(f'{name}指标.csv')
df = df.dropna()

# 日期分组
df_grouped = df.groupby('日期')

# 选取每天EMA9收盘动能3最大的四十分之一股票进入备选池
n_stock = len(df)//40
df_sorted = df_grouped.apply(lambda x: x.nlargest(n_stock, 'EMA9收盘动能3'))

# 继续选取EMA121收盘比值最小的四十分之一股票进入统计范围，作为交易标的
n_tradable = len(df_sorted)//40
df_tradable = df_sorted.nsmallest(n_tradable, 'EMA121收盘比值')

# 添加过滤条件
df_filtered = df_tradable[(df_tradable['开盘'] <= 0.9) &
                          (df_tradable['开盘幅'] <= 9.9) &
                          (df_tradable['开盘幅'] >= -0.01)]
for n in range(1, 20):
    column_name = f'{n}日后总涨跌幅（未来函数）'
    df_filtered = df_filtered[df_filtered[column_name] <= 300*(1+n*0.2)]
# 将交易标的细节输出到一个csv文件
trading_detail_filename = '交易标的细节.csv'
df_filtered.to_csv(trading_detail_filename, index=False)
# 设置交易股票代码
tradables = set(df_filtered['代码'].to_list())

avg_returns = {}
for days in range(1, 21):
    
    column_name = f'{days}日后总涨跌幅（未来函数）'
    returns = []
    for stock in tradables:
        df_stock = df[df['代码'] == stock]
        df_stock_filtered = df_stock[(df_stock['开盘'] <= 0.9) &
                                     (df_stock['开盘幅'] <= 9.9) &
                                     (df_stock['开盘幅'] >= -0.01)]
        for n in range(1, days+1):
            future_returns_column = f'{n}日后总涨跌幅（未来函数）'
            df_stock_filtered = df_stock_filtered[df_stock_filtered[future_returns_column] <= 300*(
                1+n*0.2)]
        avg_return = df_stock_filtered[column_name].mean()
        if not pd.isnull(avg_return):
            returns.append(avg_return)
    avg_return = sum(returns)/len(returns)
    avg_returns[f'{days}日后'] = [avg_return]
avg_returns_df = pd.DataFrame.from_dict(avg_returns)
avg_returns_df.to_csv('收益率.csv', index=False)

